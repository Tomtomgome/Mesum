\hypertarget{classm_1_1m_callback}{}\doxysection{m\+::m\+Callback\texorpdfstring{$<$}{<} t\+\_\+\+Ret\+Type, t\+\_\+\+Args \texorpdfstring{$>$}{>} Class Template Reference}
\label{classm_1_1m_callback}\index{m::mCallback$<$ t\_RetType, t\_Args $>$@{m::mCallback$<$ t\_RetType, t\_Args $>$}}


Class encapsulating a callback.  




{\ttfamily \#include $<$Callbacks.\+hpp$>$}

\doxysubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classm_1_1m_callback_ade0c31357b0e4d1f33ba842cb2e41b04}\label{classm_1_1m_callback_ade0c31357b0e4d1f33ba842cb2e41b04}} 
using {\bfseries m\+Function\+Type} = t\+\_\+\+Ret\+Type(t\+\_\+\+Args...)
\begin{DoxyCompactList}\small\item\em Alias the type of the function in the callback. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classm_1_1m_callback_a34b6e899fa571ae511ae2cafda9872d9}\label{classm_1_1m_callback_a34b6e899fa571ae511ae2cafda9872d9}} 
{\bfseries m\+Callback} ()=default
\begin{DoxyCompactList}\small\item\em Default constructor. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename t\+\_\+\+CArgs $>$ }\\\mbox{\hyperlink{classm_1_1m_callback_aa0eac6739ee64075289c0410caa6f14e}{m\+Callback}} (t\+\_\+\+CArgs $\ast$a\+\_\+owner, t\+\_\+\+Ret\+Type(t\+\_\+\+CArgs\+::$\ast$a\+\_\+func)(t\+\_\+\+Args...))
\begin{DoxyCompactList}\small\item\em Constructor for member functions. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classm_1_1m_callback_a530ef5e956e46dbae7e904eac6c67a91}{m\+Callback}} (std\+::function$<$ \mbox{\hyperlink{classm_1_1m_callback_ade0c31357b0e4d1f33ba842cb2e41b04}{m\+Function\+Type}} $>$ const \&a\+\_\+func)
\begin{DoxyCompactList}\small\item\em Constructor from usual std\+::function. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classm_1_1m_callback_a204f76e43710fd71904277efd494bf36}{m\+Callback}} (std\+::function$<$ \mbox{\hyperlink{classm_1_1m_callback_ade0c31357b0e4d1f33ba842cb2e41b04}{m\+Function\+Type}} $>$ \&\&a\+\_\+func)
\begin{DoxyCompactList}\small\item\em Move constructor from usual std\+::function. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename t\+\_\+\+CArgs $>$ }\\void \mbox{\hyperlink{classm_1_1m_callback_a08e0c1570e03ccb8caccec23644c2b13}{set}} (t\+\_\+\+CArgs $\ast$a\+\_\+owner, t\+\_\+\+Ret\+Type(t\+\_\+\+CArgs\+::$\ast$a\+\_\+func)(t\+\_\+\+Args...))
\begin{DoxyCompactList}\small\item\em Explicit setter for member functions. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classm_1_1m_callback_ac79bd8006224a4d446be24a111ee6a4d}{set}} (std\+::function$<$ \mbox{\hyperlink{classm_1_1m_callback_ade0c31357b0e4d1f33ba842cb2e41b04}{m\+Function\+Type}} $>$ const \&a\+\_\+func)
\begin{DoxyCompactList}\small\item\em explicit setter for usual std\+::function \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classm_1_1m_callback_ad1d9cecb679dd3bade3de9758cb0bb20}{set}} (std\+::function$<$ \mbox{\hyperlink{classm_1_1m_callback_ade0c31357b0e4d1f33ba842cb2e41b04}{m\+Function\+Type}} $>$ \&\&a\+\_\+func)
\begin{DoxyCompactList}\small\item\em explicit setter for usual std\+::function \end{DoxyCompactList}\item 
t\+\_\+\+Ret\+Type \mbox{\hyperlink{classm_1_1m_callback_a91a172c066c1c2d8a47cafeb94da77a6}{call}} (t\+\_\+\+Args... a\+\_\+args)
\begin{DoxyCompactList}\small\item\em Call the underlying function. \end{DoxyCompactList}\item 
t\+\_\+\+Ret\+Type \mbox{\hyperlink{classm_1_1m_callback_a7709c741ce81dde79460c00761ced546}{operator()}} (t\+\_\+\+Args... a\+\_\+args)
\begin{DoxyCompactList}\small\item\em Function call operator, work just like the call function. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classm_1_1m_callback_ac76b7ca7cc0c33144fbab3d1c47ee692}{operator bool}} () const
\begin{DoxyCompactList}\small\item\em Explicit convertion operator to bool. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classm_1_1m_callback_ae4aee5ac7416e0a0b04e6472b70f7e81}\label{classm_1_1m_callback_ae4aee5ac7416e0a0b04e6472b70f7e81}} 
std\+::function$<$ \mbox{\hyperlink{classm_1_1m_callback_ade0c31357b0e4d1f33ba842cb2e41b04}{m\+Function\+Type}} $>$ {\bfseries m\+\_\+func}
\begin{DoxyCompactList}\small\item\em The underlying std\+::function. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Friends}
\begin{DoxyCompactItemize}
\item 
Bool \mbox{\hyperlink{classm_1_1m_callback_ab5e50be73b4f50c578820324d30432d0}{operator==}} (const \mbox{\hyperlink{classm_1_1m_callback}{m\+Callback}} \&lhs, const \mbox{\hyperlink{classm_1_1m_callback}{m\+Callback}} \&rhs)
\begin{DoxyCompactList}\small\item\em Equal To operator. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\subsubsection*{template$<$typename t\+\_\+\+Ret\+Type, typename... t\+\_\+\+Args$>$\newline
class m\+::m\+Callback$<$ t\+\_\+\+Ret\+Type, t\+\_\+\+Args $>$}
Class encapsulating a callback. 

It can hold any kind of function (members, lambdas, etc...). Warning, it is not a performant implementation, and there is a std\+::function under the hood


\begin{DoxyTemplParams}{Template Parameters}
{\em t\+\_\+\+Ret\+Type} & The return type of the callback \\
\hline
{\em t\+\_\+\+Args} & The list of arguments of the function \\
\hline
\end{DoxyTemplParams}


\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classm_1_1m_callback_aa0eac6739ee64075289c0410caa6f14e}\label{classm_1_1m_callback_aa0eac6739ee64075289c0410caa6f14e}} 
\index{m::mCallback$<$ t\_RetType, t\_Args $>$@{m::mCallback$<$ t\_RetType, t\_Args $>$}!mCallback@{mCallback}}
\index{mCallback@{mCallback}!m::mCallback$<$ t\_RetType, t\_Args $>$@{m::mCallback$<$ t\_RetType, t\_Args $>$}}
\doxysubsubsection{\texorpdfstring{mCallback()}{mCallback()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename t\+\_\+\+Ret\+Type , typename... t\+\_\+\+Args$>$ \\
template$<$typename t\+\_\+\+CArgs $>$ \\
\mbox{\hyperlink{classm_1_1m_callback}{m\+::m\+Callback}}$<$ t\+\_\+\+Ret\+Type, t\+\_\+\+Args $>$\+::\mbox{\hyperlink{classm_1_1m_callback}{m\+Callback}} (\begin{DoxyParamCaption}\item[{t\+\_\+\+CArgs $\ast$}]{a\+\_\+owner,  }\item[{t\+\_\+\+Ret\+Type(t\+\_\+\+CArgs\+::$\ast$)(t\+\_\+\+Args...)}]{a\+\_\+func }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Constructor for member functions. 


\begin{DoxyTemplParams}{Template Parameters}
{\em t\+\_\+\+CArgs} & The type of the class from witch we get the function \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em a\+\_\+owner} & A pointer to the object to which the callback call the member function \\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
a\+\_\+owner can\textquotesingle{}t be nullptr 
\end{DoxyPrecond}

\begin{DoxyParams}{Parameters}
{\em a\+\_\+func} & The member function of the class t\+\_\+\+CArg for the callback \\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
a\+\_\+func can\textquotesingle{}t be nullptr 
\end{DoxyPrecond}
\mbox{\Hypertarget{classm_1_1m_callback_a530ef5e956e46dbae7e904eac6c67a91}\label{classm_1_1m_callback_a530ef5e956e46dbae7e904eac6c67a91}} 
\index{m::mCallback$<$ t\_RetType, t\_Args $>$@{m::mCallback$<$ t\_RetType, t\_Args $>$}!mCallback@{mCallback}}
\index{mCallback@{mCallback}!m::mCallback$<$ t\_RetType, t\_Args $>$@{m::mCallback$<$ t\_RetType, t\_Args $>$}}
\doxysubsubsection{\texorpdfstring{mCallback()}{mCallback()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename t\+\_\+\+Ret\+Type , typename... t\+\_\+\+Args$>$ \\
\mbox{\hyperlink{classm_1_1m_callback}{m\+::m\+Callback}}$<$ t\+\_\+\+Ret\+Type, t\+\_\+\+Args $>$\+::\mbox{\hyperlink{classm_1_1m_callback}{m\+Callback}} (\begin{DoxyParamCaption}\item[{std\+::function$<$ \mbox{\hyperlink{classm_1_1m_callback_ade0c31357b0e4d1f33ba842cb2e41b04}{m\+Function\+Type}} $>$ const \&}]{a\+\_\+func }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [explicit]}}



Constructor from usual std\+::function. 

Implicit conversion makes it work with any king of usual function pointers


\begin{DoxyParams}{Parameters}
{\em a\+\_\+func} & The function for the callback \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classm_1_1m_callback_a204f76e43710fd71904277efd494bf36}\label{classm_1_1m_callback_a204f76e43710fd71904277efd494bf36}} 
\index{m::mCallback$<$ t\_RetType, t\_Args $>$@{m::mCallback$<$ t\_RetType, t\_Args $>$}!mCallback@{mCallback}}
\index{mCallback@{mCallback}!m::mCallback$<$ t\_RetType, t\_Args $>$@{m::mCallback$<$ t\_RetType, t\_Args $>$}}
\doxysubsubsection{\texorpdfstring{mCallback()}{mCallback()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename t\+\_\+\+Ret\+Type , typename... t\+\_\+\+Args$>$ \\
\mbox{\hyperlink{classm_1_1m_callback}{m\+::m\+Callback}}$<$ t\+\_\+\+Ret\+Type, t\+\_\+\+Args $>$\+::\mbox{\hyperlink{classm_1_1m_callback}{m\+Callback}} (\begin{DoxyParamCaption}\item[{std\+::function$<$ \mbox{\hyperlink{classm_1_1m_callback_ade0c31357b0e4d1f33ba842cb2e41b04}{m\+Function\+Type}} $>$ \&\&}]{a\+\_\+func }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [explicit]}}



Move constructor from usual std\+::function. 

Implicit conversion makes it work with any king of usual function pointers


\begin{DoxyParams}{Parameters}
{\em a\+\_\+func} & The function for the callback \\
\hline
\end{DoxyParams}


\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classm_1_1m_callback_a91a172c066c1c2d8a47cafeb94da77a6}\label{classm_1_1m_callback_a91a172c066c1c2d8a47cafeb94da77a6}} 
\index{m::mCallback$<$ t\_RetType, t\_Args $>$@{m::mCallback$<$ t\_RetType, t\_Args $>$}!call@{call}}
\index{call@{call}!m::mCallback$<$ t\_RetType, t\_Args $>$@{m::mCallback$<$ t\_RetType, t\_Args $>$}}
\doxysubsubsection{\texorpdfstring{call()}{call()}}
{\footnotesize\ttfamily template$<$typename t\+\_\+\+Ret\+Type , typename... t\+\_\+\+Args$>$ \\
t\+\_\+\+Ret\+Type \mbox{\hyperlink{classm_1_1m_callback}{m\+::m\+Callback}}$<$ t\+\_\+\+Ret\+Type, t\+\_\+\+Args $>$\+::call (\begin{DoxyParamCaption}\item[{t\+\_\+\+Args...}]{a\+\_\+args }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Call the underlying function. 


\begin{DoxyParams}{Parameters}
{\em a\+\_\+args} & The list of arguments for the call \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the result of the function 
\end{DoxyReturn}
\mbox{\Hypertarget{classm_1_1m_callback_ac76b7ca7cc0c33144fbab3d1c47ee692}\label{classm_1_1m_callback_ac76b7ca7cc0c33144fbab3d1c47ee692}} 
\index{m::mCallback$<$ t\_RetType, t\_Args $>$@{m::mCallback$<$ t\_RetType, t\_Args $>$}!operator bool@{operator bool}}
\index{operator bool@{operator bool}!m::mCallback$<$ t\_RetType, t\_Args $>$@{m::mCallback$<$ t\_RetType, t\_Args $>$}}
\doxysubsubsection{\texorpdfstring{operator bool()}{operator bool()}}
{\footnotesize\ttfamily template$<$typename t\+\_\+\+Ret\+Type , typename... t\+\_\+\+Args$>$ \\
\mbox{\hyperlink{classm_1_1m_callback}{m\+::m\+Callback}}$<$ t\+\_\+\+Ret\+Type, t\+\_\+\+Args $>$\+::operator bool (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [explicit]}}



Explicit convertion operator to bool. 

\begin{DoxyReturn}{Returns}
true if the function has been set, false otherwise 
\end{DoxyReturn}
\mbox{\Hypertarget{classm_1_1m_callback_a7709c741ce81dde79460c00761ced546}\label{classm_1_1m_callback_a7709c741ce81dde79460c00761ced546}} 
\index{m::mCallback$<$ t\_RetType, t\_Args $>$@{m::mCallback$<$ t\_RetType, t\_Args $>$}!operator()@{operator()}}
\index{operator()@{operator()}!m::mCallback$<$ t\_RetType, t\_Args $>$@{m::mCallback$<$ t\_RetType, t\_Args $>$}}
\doxysubsubsection{\texorpdfstring{operator()()}{operator()()}}
{\footnotesize\ttfamily template$<$typename t\+\_\+\+Ret\+Type , typename... t\+\_\+\+Args$>$ \\
t\+\_\+\+Ret\+Type \mbox{\hyperlink{classm_1_1m_callback}{m\+::m\+Callback}}$<$ t\+\_\+\+Ret\+Type, t\+\_\+\+Args $>$\+::operator() (\begin{DoxyParamCaption}\item[{t\+\_\+\+Args...}]{a\+\_\+args }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Function call operator, work just like the call function. 


\begin{DoxyParams}{Parameters}
{\em a\+\_\+args} & The list of arguments for the call \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the result of the function 
\end{DoxyReturn}
\mbox{\Hypertarget{classm_1_1m_callback_ad1d9cecb679dd3bade3de9758cb0bb20}\label{classm_1_1m_callback_ad1d9cecb679dd3bade3de9758cb0bb20}} 
\index{m::mCallback$<$ t\_RetType, t\_Args $>$@{m::mCallback$<$ t\_RetType, t\_Args $>$}!set@{set}}
\index{set@{set}!m::mCallback$<$ t\_RetType, t\_Args $>$@{m::mCallback$<$ t\_RetType, t\_Args $>$}}
\doxysubsubsection{\texorpdfstring{set()}{set()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename t\+\_\+\+Ret\+Type , typename... t\+\_\+\+Args$>$ \\
void \mbox{\hyperlink{classm_1_1m_callback}{m\+::m\+Callback}}$<$ t\+\_\+\+Ret\+Type, t\+\_\+\+Args $>$\+::set (\begin{DoxyParamCaption}\item[{std\+::function$<$ \mbox{\hyperlink{classm_1_1m_callback_ade0c31357b0e4d1f33ba842cb2e41b04}{m\+Function\+Type}} $>$ \&\&}]{a\+\_\+func }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



explicit setter for usual std\+::function 

Implicit conversion makes it work with any king of usual function pointers


\begin{DoxyParams}{Parameters}
{\em a\+\_\+func} & The function for the callback \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classm_1_1m_callback_ac79bd8006224a4d446be24a111ee6a4d}\label{classm_1_1m_callback_ac79bd8006224a4d446be24a111ee6a4d}} 
\index{m::mCallback$<$ t\_RetType, t\_Args $>$@{m::mCallback$<$ t\_RetType, t\_Args $>$}!set@{set}}
\index{set@{set}!m::mCallback$<$ t\_RetType, t\_Args $>$@{m::mCallback$<$ t\_RetType, t\_Args $>$}}
\doxysubsubsection{\texorpdfstring{set()}{set()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename t\+\_\+\+Ret\+Type , typename... t\+\_\+\+Args$>$ \\
void \mbox{\hyperlink{classm_1_1m_callback}{m\+::m\+Callback}}$<$ t\+\_\+\+Ret\+Type, t\+\_\+\+Args $>$\+::set (\begin{DoxyParamCaption}\item[{std\+::function$<$ \mbox{\hyperlink{classm_1_1m_callback_ade0c31357b0e4d1f33ba842cb2e41b04}{m\+Function\+Type}} $>$ const \&}]{a\+\_\+func }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



explicit setter for usual std\+::function 

Implicit conversion makes it work with any king of usual function pointers


\begin{DoxyParams}{Parameters}
{\em a\+\_\+func} & The function for the callback \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classm_1_1m_callback_a08e0c1570e03ccb8caccec23644c2b13}\label{classm_1_1m_callback_a08e0c1570e03ccb8caccec23644c2b13}} 
\index{m::mCallback$<$ t\_RetType, t\_Args $>$@{m::mCallback$<$ t\_RetType, t\_Args $>$}!set@{set}}
\index{set@{set}!m::mCallback$<$ t\_RetType, t\_Args $>$@{m::mCallback$<$ t\_RetType, t\_Args $>$}}
\doxysubsubsection{\texorpdfstring{set()}{set()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename t\+\_\+\+Ret\+Type , typename... t\+\_\+\+Args$>$ \\
template$<$typename t\+\_\+\+CArgs $>$ \\
void \mbox{\hyperlink{classm_1_1m_callback}{m\+::m\+Callback}}$<$ t\+\_\+\+Ret\+Type, t\+\_\+\+Args $>$\+::set (\begin{DoxyParamCaption}\item[{t\+\_\+\+CArgs $\ast$}]{a\+\_\+owner,  }\item[{t\+\_\+\+Ret\+Type(t\+\_\+\+CArgs\+::$\ast$)(t\+\_\+\+Args...)}]{a\+\_\+func }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Explicit setter for member functions. 


\begin{DoxyTemplParams}{Template Parameters}
{\em t\+\_\+\+CArgs} & The type of the class from witch we get the function \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em a\+\_\+owner} & A pointer to the object to which the callback call the member function \\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
a\+\_\+owner can\textquotesingle{}t be nullptr 
\end{DoxyPrecond}

\begin{DoxyParams}{Parameters}
{\em a\+\_\+func} & The member function of the class t\+\_\+\+CArg for the callback \\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
a\+\_\+func can\textquotesingle{}t be nullptr 
\end{DoxyPrecond}


\doxysubsection{Friends And Related Function Documentation}
\mbox{\Hypertarget{classm_1_1m_callback_ab5e50be73b4f50c578820324d30432d0}\label{classm_1_1m_callback_ab5e50be73b4f50c578820324d30432d0}} 
\index{m::mCallback$<$ t\_RetType, t\_Args $>$@{m::mCallback$<$ t\_RetType, t\_Args $>$}!operator==@{operator==}}
\index{operator==@{operator==}!m::mCallback$<$ t\_RetType, t\_Args $>$@{m::mCallback$<$ t\_RetType, t\_Args $>$}}
\doxysubsubsection{\texorpdfstring{operator==}{operator==}}
{\footnotesize\ttfamily template$<$typename t\+\_\+\+Ret\+Type , typename... t\+\_\+\+Args$>$ \\
Bool operator== (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classm_1_1m_callback}{m\+Callback}}$<$ t\+\_\+\+Ret\+Type, t\+\_\+\+Args $>$ \&}]{lhs,  }\item[{const \mbox{\hyperlink{classm_1_1m_callback}{m\+Callback}}$<$ t\+\_\+\+Ret\+Type, t\+\_\+\+Args $>$ \&}]{rhs }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [friend]}}



Equal To operator. 

\begin{DoxyReturn}{Returns}
true if the functions are the same 
\end{DoxyReturn}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
Mesum\+Core/\+Kernel/Callbacks.\+hpp\end{DoxyCompactItemize}
