#pragma once

#include "MathTypes.hpp"
#include "Types.hpp"

///////////////////////////////////////////////////////////////////////////////
/// \addtogroup Core
/// \{
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
/// \brief Namespace for math related utils
///////////////////////////////////////////////////////////////////////////////
namespace m::math
{
///////////////////////////////////////////////////////////////////////////////
/// \brief Linearly interpolate two numerical values
///
/// \tparam t_T The type to interpolate
/// \param a_a The first value of the interpolation
/// \param a_b The second value of the interpolation
/// \param a_ratio The ratio of the interpolation
/// \return (1.0 - a_ratio) * a_a + a_ratio * a_b
///////////////////////////////////////////////////////////////////////////////
template <typename t_T>
t_T lerp(t_T const& a_a, t_T const& a_b, mDouble a_ratio)
{
    return (1.0 - a_ratio) * a_a + a_ratio * a_b;
}

///////////////////////////////////////////////////////////////////////////////
/// \brief RandomNumberGenerator using XorShift
///
/// All numbers generated with this generator are correlated
///////////////////////////////////////////////////////////////////////////////
class mXoRandomNumberGenerator
{
   public:
    ///////////////////////////////////////////////////////////////////////////
    /// \brief Construct a randonc number generator
    ///
    /// \param a_seed The seed for the number generation
    ///////////////////////////////////////////////////////////////////////////
    explicit mXoRandomNumberGenerator(mU64 a_seed);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief get a random number
    ///
    /// \return a random mU64
    ///////////////////////////////////////////////////////////////////////////
    mU64 get_nextU64();

    ///////////////////////////////////////////////////////////////////////////
    /// \brief get a random number
    ///
    /// \return a random mU32
    ///////////////////////////////////////////////////////////////////////////
    mU32 get_nextU32();

    ///////////////////////////////////////////////////////////////////////////
    /// \brief get a random number
    ///
    /// \return a random double
    ///////////////////////////////////////////////////////////////////////////
    mDouble get_nextDouble();

    ///////////////////////////////////////////////////////////////////////////
    /// \brief get a random number
    ///
    /// \return a random float
    ///////////////////////////////////////////////////////////////////////////
    mFloat get_nextFloat();

   private:
    ///////////////////////////////////////////////////////////////////////////
    /// \brief State of the xoshiro algorithm
    ///////////////////////////////////////////////////////////////////////////
    struct mXoshiro256ssState
    {
        mU64 s[4];
    };

   private:
    ///////////////////////////////////////////////////////////////////////////
    /// \brief Current state of the generator
    ///////////////////////////////////////////////////////////////////////////
    mXoshiro256ssState m_state = {0, 0, 0, 0};
};

}  // namespace m::math

///////////////////////////////////////////////////////////////////////////////
/// \}
///////////////////////////////////////////////////////////////////////////////
